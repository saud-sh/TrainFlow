GOAL:


Add a first-class email + password authentication system using the existing users table.


Make the landing page “Login” button go to a real /login page that uses this auth.


Connect the authenticated user to the EXISTING role-based routes and side navigation, without changing route paths or breaking current pages.


Keep Replit Auth only as an optional developer backdoor (not used in the normal login flow).


IMPORTANT CONSTRAINTS (DO NOT VIOLATE):


Use the current architecture (FastAPI backend, React/Vite/TS frontend in client/).


client/ is the ACTIVE frontend. Do NOT touch frontend/ except to copy code if needed.


No destructive DB migrations:


NO DROP TABLE


NO DROP COLUMN


NO ALTER DROP / CASCADE




Multi-tenant safety must remain enforced (tenant_id on all queries).


RBAC must remain enforced as defined in the blueprint.


Route paths and semantics must NOT change. Only attach auth/role checks to them.


Reference (existing route map – DO NOT CHANGE PATHS):


Employee:


/dashboard


/my-courses


/my-renewals


/progression


/ai-recommendations


/grade-readiness


/kpi-dashboard




Foreman:


All employee routes plus:


/approvals


/team




Manager:


All foreman routes plus:


/reports




Training Officer:


/courses


/enrollments


/all-renewals


/reports




Administrator:


/users


/departments


/integrations


/audit-logs


/reports


Full visibility for all above




You MUST connect the new auth to this existing routing and navigation. Do NOT invent new routes.



BACKEND – AUTH LAYER (FastAPI)



A. Auth Service and Utilities
Create or update: backend/app/services/auth_service.py
Implement:


hash_password(plain_password: str) -> str


Use passlib + bcrypt (already in requirements).




verify_password(plain_password: str, password_hash: str) -> bool


create_access_token(data: dict, expires_minutes: int) -> str


Use JWT_SECRET and JWT_ALGORITHM from settings.


Include at minimum: sub (user id), tenant_id, role.




decode_access_token(token: str) -> dict


Validate token, raise appropriate HTTPException on failure.




These helpers will be reused by routes and seed logic.
B. HttpOnly JWT Cookie Flow
Use HttpOnly, Secure cookie for auth:


Cookie name: trainflow_access_token


SameSite: Lax


Path: /


Do NOT store JWT in localStorage. Only in HttpOnly cookie.
C. Auth Router
Create new router file: backend/app/api/v1/auth.py
Implement endpoints:


POST /api/v1/auth/login




Request body:
{
"email": "string",
"password": "string"
}


Logic:


Look up user by email (case-insensitive) in users table.


Ensure:


user.is_active = True


user.tenant_id is not null




Use verify_password to check password.


On success:


Create JWT with:


sub: user.id


tenant_id: user.tenant_id


role: user.role


any other needed claims (e.g., email).




Set JWT in trainflow_access_token HttpOnly cookie.


Return JSON:
{
"success": true,
"user": {
"id": ...,
"email": ...,
"role": ...,
"tenant_id": ...,
"first_name": ...,
"last_name": ...
}
}




On failure:


Return 401 with JSON:
{ "success": false, "error": "invalid_credentials" }








POST /api/v1/auth/logout




Clear the trainflow_access_token cookie by setting an expired cookie.


Return { "success": true }.




GET /api/v1/auth/me




Read JWT from cookie.


Decode and load user from DB.


Return:
{
"id": ...,
"email": ...,
"role": ...,
"tenant_id": ...,
"first_name": ...,
"last_name": ...
}


D. Auth Dependency + RBAC
Create or update: backend/app/middleware/auth.py (or appropriate module):


get_current_user(db=Depends(...)):


Read cookie trainflow_access_token.


Decode JWT.


Load user by id.


Ensure:


user.is_active


tenant_id in token matches user.tenant_id




Attach user and tenant_id to request context (e.g., via request.state or returning the user object).




require_role(*allowed_roles):


Callable/dependency that:


Uses get_current_user.


Checks user.role is in allowed_roles.


Returns user if allowed, otherwise raises 403.






You MUST plug this dependency into EXISTING routers WITHOUT changing their paths. For example:


Employee-only endpoints:


Use Depends(get_current_user) with roles including employee, foreman, manager, training_officer, administrator as appropriate.




Foreman / Manager endpoints:


Use require_role("foreman", "manager", "administrator").




Admin endpoints:


Use require_role("administrator") only.




Use the existing UserRole enum instead of magic strings wherever defined.
E. Integration into main.py
In backend/app/main.py:


Include auth router:
app.include_router(auth.router, prefix="/api/v1/auth", tags=["auth"])


Ensure CORS, security middleware, and existing routers remain unchanged.


F. Replit Auth Backdoor (Dev Only)
If there is an existing Replit auth integration, keep it but scope it for development only:


Example: GET /api/v1/dev/replit-login


Only enabled when settings.ENVIRONMENT in ("dev", "replit").


It may map the Replit user email to an existing admin user.


This backdoor MUST NOT be referenced in the landing page or login UI.




Do NOT remove existing Replit settings; only make sure the main login route for end users is /api/v1/auth/login.
G. Database
If users.password_hash column exists:


Do NOT create any migrations.


If not:


Create ONE additive-only Alembic migration:


Add Column password_hash VARCHAR(255) NULL to users.




No drops, no destructive operations.





BACKEND – DEMO SEED DATA (REAL PASSWORDS)



Update backend/app/seeds/demo_seed.py (or equivalent):


Use hash_password from auth_service.py to store real passwords.


For each existing demo user, ensure password_hash is set.


Define at least these demo accounts (update emails if different in the blueprint, but keep consistent across code and docs):


Administrator
email: admin@democorp.local
password: TrainFlow123!
role: administrator


Training Officer
email: training@democorp.local
password: TrainFlow123!
role: training_officer


Manager
email: manager@democorp.local
password: TrainFlow123!
role: manager


Foreman
email: foreman@democorp.local
password: TrainFlow123!
role: foreman


Employee
email: employee@democorp.local
password: TrainFlow123!
role: employee


Rules:


Seed function must be idempotent:


If a user with that email already exists, update its password_hash and keep the rest (tenant, dept, etc.).




Keep tenant_id and department relationships exactly as defined in the existing seed logic.


Update replit.md:


Add “Demo Login Accounts” section listing these emails and passwords.


Document that login is via POST /api/v1/auth/login (HttpOnly JWT cookie).





FRONTEND – LOGIN PAGE & ROUTE WIRING (client/)



IMPORTANT:


Work ONLY under client/ (this is the active app).


Do NOT change any existing route paths.


Do NOT change any dashboard layout.


Only implement login page + auth store wiring + guarding routes by role.


A. Auth API Client
If not already present, add in client/src/services/api.ts or similar:


axios instance configured with:


baseURL pointing to API root (existing pattern).


withCredentials: true (to send/receive cookies).




Add functions:


login(email, password) -> calls POST /api/v1/auth/login


logout() -> POST /api/v1/auth/logout


getCurrentUser() -> GET /api/v1/auth/me


B. Auth Store (Zustand)
In client/src/store/authStore.ts (or existing store):


State:


user: { id, email, role, tenantId, firstName, lastName } | null


loading: boolean


error: string | null




Actions:


login(email, password):


call API, set user, clear error.




logout():


call API logout, clear user, redirect to landing.




hydrate():


on app startup, call /api/v1/auth/me


if 200, set user; otherwise keep as null.






C. Login Page Component
Create or update: client/src/pages/Login.tsx
Requirements:


Use the same visual language as current app (dark/light theme, buttons, etc.).


Fields:


Email


Password


“Remember me” checkbox (optional functionality).




Buttons:


Primary: “Login” (EN) / “تسجيل الدخول” (AR)


Secondary: “Back to Home” -> navigate to “/”




Behavior:


On submit:


Call authStore.login(email, password).


Show spinner/loading state.


On 401 error: show translated “Invalid email or password” message.


On other errors: show generic error.




On success:


Redirect based on role, using EXISTING ROUTES:
If role in ["employee"]:
redirect to "/dashboard"
If role in ["foreman"]:
redirect to "/dashboard"
If role in ["manager"]:
redirect to "/dashboard"
If role in ["training_officer"]:
redirect to "/dashboard" or the current designed default admin view
If role in ["administrator"]:
redirect to "/dashboard"


Do NOT create new routes. Just reuse /dashboard as entry.






i18n:


All texts on the login page should be read from existing translation system (EN/AR).


Use same language/RTL toggle as landing page header.




D. Routing and Guards
In client/src/App.tsx or wherever Router is defined:


Route definitions:




Add route:
path="/login" -> element=<LoginPage />


Ensure root path "/":


For unauthenticated users:


Show landing page (current hero, features, etc.).




For authenticated users:


Immediately redirect to "/dashboard".








Protected routes:




For each existing route, wrap with a component/higher-order route that checks:


If user is NOT logged in -> redirect to "/login".


If user is logged in but role is NOT allowed for that path -> show a 403 page or redirect to "/dashboard".




Role mapping (do NOT change paths, only add guards):


Employee allowed:


/dashboard


/my-courses


/my-renewals


/progression


/ai-recommendations


/grade-readiness


/kpi-dashboard




Foreman allowed:


All employee routes


/approvals


/team




Manager allowed:


All foreman routes


/reports




Training Officer allowed:


/courses


/enrollments


/all-renewals


/reports




Administrator allowed:


All of the above plus:


/users


/departments


/integrations


/audit-logs






Implement a small helper components like:


<ProtectedRoute roles={["employee", "foreman", ...]}>
<DashboardPage />
</ProtectedRoute>


Where ProtectedRoute uses authStore.user.role to decide.
The side navigation should remain as is. If you already conditionally show menu items by role, reuse the same role constants. Do not change the menu structure; just ensure the route guards match it.
E. Landing Page “Login” Button
In the landing hero component (in client/src components), update:


The “Login” button:


Uses React Router to navigate to "/login".


No Replit popup; no OIDC screen in the normal flow.




The “Request Demo” button:


Should either scroll to a contact section or open mailto:info@rocktech.sa
Example: href="mailto:info@rocktech.sa?subject=TrainFlow%20Demo%20Request"




Keep animations and layout unchanged.



OUT OF SCOPE (THIS PHASE)





No changes to:


KPI logic


Renewal workflow logic


AI modules


Integration connectors


Background jobs




No redesign of dashboard containers or card layouts.


No schema cleanup.





QUALITY GATES BEFORE YOU STOP



Backend:


All new auth endpoints work:


/api/v1/auth/login


/api/v1/auth/logout


/api/v1/auth/me




No destructive Alembic migrations.


Multi-tenant rules still applied (tenant_id from token used in queries).


RBAC is enforced on all protected routes consistent with the paths listed above.


Frontend:


Landing page at "/":


Shows current bilingual hero/features.


“Login” -> /login.


“Request Demo” -> mailto or contact section.




/login:


Submits to /api/v1/auth/login.


Works in both English and Arabic.


On success, redirects to /dashboard with correct navigation for the user’s role.




Unauthenticated user trying to visit /dashboard or any protected route -> redirected to /login.


Authenticated user visiting "/" -> redirected to /dashboard.


Role-restricted routes:


Employee cannot access admin pages (users, departments, etc.).


Only Admin can open /users, /departments, /integrations, /audit-logs.


Foreman and Manager see their respective sections as defined.




Documentation:


replit.md updated with:


Description of new auth flow.


Demo emails and password.


How to seed and test:


Run seed endpoint.


Use /login with demo users.






At the end, summarize:


Files created/modified (backend + frontend).


Exact demo steps:


Call seed, then login as admin@democorp.local / TrainFlow123! at /login, and verify role-based navigation and routes.




Execute ONLY this phase and stop after all above is implemented and verified.
