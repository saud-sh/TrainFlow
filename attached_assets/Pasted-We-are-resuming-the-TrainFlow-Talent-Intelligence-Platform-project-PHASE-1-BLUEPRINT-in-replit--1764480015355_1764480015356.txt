We are resuming the TrainFlow Talent Intelligence Platform project.

PHASE 1 – BLUEPRINT in `replit.md` IS APPROVED and is the SINGLE SOURCE OF TRUTH.

You must now IMPLEMENT the platform according to the blueprint and the Rock Technology protocols, using the environment variables already configured in this Replit:

AVAILABLE ENV VARS (do NOT print their values):
- DATABASE_URL
- PGDATABASE, PGHOST, PGPORT, PGUSER, PGPASSWORD
- OPENAI_API_KEY
- AI_INTEGRATIONS_OPENAI_API_KEY
- AI_INTEGRATIONS_OPENAI_BASE_URL
- SENDGRID_API_KEY
- EMAIL_FROM_ADDRESS
- EMAIL_FROM_NAME
- SESSION_SECRET
- JWT_SECRET
- JWT_ALGORITHM
- ACCESS_TOKEN_EXPIRE_MINUTES
- SCHEDULER_ENABLED

=====================================================
GLOBAL RULES (DO NOT VIOLATE)
=====================================================

- Backend MUST be Python + FastAPI + SQLAlchemy + Alembic.
- Frontend MUST be React + Vite + TypeScript + TailwindCSS + ShadCN + Zustand.
- Use the modular monolith + bounded contexts EXACTLY as defined in `replit.md`.
- Multi-tenant: ALL business tables must include tenant_id and ALL queries must be tenant-scoped.
- Migrations MUST be ADDITIVE ONLY:
  - NO DROP TABLE
  - NO DROP COLUMN
  - NO ALTER ... DROP
  - NO CASCADE SCHEMA DELETION
- AI logic MUST be in background jobs / service layer, NOT directly in HTTP handlers.
- RBAC MUST be enforced on every protected route.
- Keep logs structured: timestamp, level, route, user_id, tenant_id where possible.
- DO NOT change the approved blueprint structure unless absolutely necessary, and if so, document it in `replit.md` under "Design Decisions".

You must now complete: Phase 2, Phase 3, and Phase 4 to deliver a WORKING, DEMO-READY MVP.

=====================================================
PHASE 2 – FOUNDATION & SETUP (DO THIS FIRST)
=====================================================

Objective:
- Create backend & frontend skeletons aligned with the blueprint and wired to environment variables.

Backend tasks:

1) Create `backend/app/core/config.py`
   - Use pydantic-settings to read all env vars listed above.
   - Expose:
     - settings.DATABASE_URL (prefer this over PG* if present)
     - settings.JWT_SECRET, settings.JWT_ALGORITHM, settings.ACCESS_TOKEN_EXPIRE_MINUTES
     - settings.SESSION_SECRET
     - settings.OPENAI_API_KEY or AI_INTEGRATIONS_OPENAI_API_KEY
     - settings.AI_INTEGRATIONS_OPENAI_BASE_URL
     - settings.SENDGRID_API_KEY
     - settings.EMAIL_FROM_ADDRESS, settings.EMAIL_FROM_NAME
     - settings.SCHEDULER_ENABLED (bool)
   - Provide sensible defaults for local dev if some variables are missing (e.g., SQLite).

2) Create `backend/app/db/database.py`
   - SQLAlchemy engine configured from settings.DATABASE_URL.
   - SessionLocal, Base, and get_db dependency.
   - Ensure correct async/sync model according to design (synchronicity should follow blueprint).

3) Configure Alembic:
   - `alembic.ini`
   - `backend/alembic/env.py` wired to SQLAlchemy metadata.
   - `backend/alembic/versions/` folder for migrations.
   - First migration for ONLY:
     - `tenants` table
     - `users` table
     - Both with tenant_id and required fields, non-destructive and additive-only.

4) Create `backend/app/main.py`
   - FastAPI app factory using settings.
   - Include:
     - CORS middleware (allow frontend origin(s) as per blueprint).
     - Security headers middleware:
       - CSP
       - HSTS
       - X-Frame-Options
       - X-Content-Type-Options
     - Logging middleware:
       - Log method, path, status, execution time, tenant, user_id when available.
     - Exception handlers for validation and unhandled errors.
   - Implement health endpoints:
     - `GET /api/health` → simple "ok" + version
     - `GET /api/health/detailed` → DB connectivity, scheduler status, AI/email config status (without exposing secrets).

5) Create EMPTY router modules (just stubs) as per blueprint:
   - users, departments, courses, enrollments, renewals, tasks, kpi, notifications, ai, integrations, audit, scorm, security_awareness, skills, career, etc.
   - Register them in `main.py` with API prefix `/api/v1/...` but keep stubs for now.

Backend MUST start successfully with the health endpoints.

Frontend tasks:

6) Initialize React + Vite + TypeScript app in `frontend/` as specified in the blueprint.
   - Configure TailwindCSS.
   - Install ShadCN UI.
   - Create a basic layout:
     - AppShell (sidebar/topbar)
     - Placeholder logo/name "TrainFlow".
   - Setup React Router with at least:
     - `/login`
     - `/` (Dashboard placeholder component)
   - Setup Axios instance with baseURL pointing to backend `/api`.
   - Setup Zustand store skeleton:
     - auth slice (holds token, current user, role).
     - tenant slice (holds current tenant).
     - other slices as placeholders only.

When Phase 2 is complete and both backend and frontend run without errors → proceed to Phase 3.

=====================================================
PHASE 3 – CORE DOMAIN & WORKFLOWS (MVP)
=====================================================

Objective:
- Implement the MINIMUM but complete vertical slice: Auth + Tenancy + RBAC + Core entities + Renewal workflow + KPIs + Notifications.

Database & Models (with Alembic migrations):

Add tables (all with tenant_id) as per blueprint:
- departments
- courses
- enrollments
- renewal_requests
- workflow_steps
- workflow_logs
- progression_tasks
- employee_tasks
- notifications
- kpi_snapshots
- audit_logs

All migrations MUST be additive-only and compatible with the initial tenants/users migration.

Authentication & RBAC:

1) Implement user model fields required by blueprint (username/email, password hash, role, department_id, grade, etc.).
2) Implement password hashing using bcrypt.
3) Implement:
   - `POST /api/auth/login`:
     - Accepts username/email + password.
     - Validates credentials.
     - Issues JWT (or session) stored in HttpOnly + Secure cookie using JWT_SECRET, JWT_ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES.
   - `POST /api/auth/logout`:
     - Clears auth cookie.
   - `GET /api/auth/me`:
     - Returns current user + role + tenant_id.
4) Implement tenant resolution middleware:
   - Extract tenant from user record or header as per blueprint.
   - Attach tenant_id to request context.
   - Enforce tenant_id filter on all ORM queries.

5) Implement RBAC middleware:
   - Roles: employee, foreman, manager, training_officer, admin.
   - Provide decorators or dependency functions for capabilities checks.
   - Enforce RBAC on all protected routes.

Core APIs (MVP):

Implement fully functional endpoints for:

- Users (Admin):
  - CRUD for users within tenant (list/create/update, no hard delete – use soft-delete flag if needed).
- Departments (Admin):
  - CRUD within tenant.
- Courses (Admin/Training Officer):
  - CRUD with expiry rules, validity period, department/category, etc.
- Enrollments (Training Officer/Admin):
  - Assign courses to users.
  - Track status: active, completed, failed, expired.
  - Endpoint for current user: `/api/my-enrollments`.
- Renewal Workflow:
  - `POST /api/renewal-requests` (Employee creates renewal for a course that is expired or expiring).
  - `GET /api/my-renewal-requests`.
  - `GET /api/renewal-requests` (Training Officer / Admin view, with filters).
  - `PATCH /api/renewal-requests/{id}/approve`:
    - Foreman or Manager depending on step.
  - `PATCH /api/renewal-requests/{id}/reject`.
  - Store full timeline in workflow_logs.
- Progression & Tasks:
  - `POST/GET/PATCH /api/progression-tasks` for defining grade-level tasks (Admin/Training Officer).
  - `GET /api/my-progression-tasks` for employees to see their tasks and completion.
  - `PATCH /api/employee-tasks/{id}` to mark complete/in-progress.

KPIs:

- Implement basic KPI aggregation endpoints:
  - `GET /api/kpi/summary`:
    - For Employee: training completion %, tasks completion %, expired ratio.
    - For Foreman/Manager: aggregated KPIs for their team.
    - For Training/Admin: department-level training KPIs.
- Use kpi_snapshots table OR compute on the fly but design for snapshots.

Notifications:

- Implement notifications table and endpoints:
  - `GET /api/notifications`
  - `PATCH /api/notifications/{id}/read`
  - `POST /api/notifications/mark-all-read`
- Integrate notifications with:
  - Renewal events
  - Expiration alerts

Audit Logging:

- Implement a central audit service that records:
  - user_id, tenant_id, action, entity, entity_id, timestamp, metadata
- Log:
  - Auth events (login/logout success/fail)
  - CRUD on core entities
  - Approvals/rejections

Background Jobs:

Use APScheduler or equivalent to implement:

- Daily course expiration check:
  - Detect enrollments expiring in 30/14/7/1 days and those already expired.
  - Create in-app notifications.
  - Create renewal suggestions.
  - Escalate to foreman if employee ignores notifications.
- Notification sending dispatcher:
  - Queue and send email notifications using SendGrid (see Phase 4 wiring).
- Use SCHEDULER_ENABLED to enable/disable job runner.

Frontend:

- Implement functional pages with basic UI (tables/forms/cards) for:
  - `/login`
  - `/` (role-based dashboard with simple KPIs and quick links)
  - `/my-courses`
  - `/my-renewals`
  - `/progression`
  - `/approvals`
  - `/team`
  - `/courses`
  - `/enrollments`
  - `/users`
  - `/departments`
  - `/kpi-dashboard`
- All pages must use Axios client and Zustand stores to talk to the FastAPI backend.
- Include proper loading states and error states.

Once Phase 3 MVP flows are working end-to-end (login → enroll → expire → renew → approve → KPIs), proceed to Phase 4.

=====================================================
PHASE 4 – DEMO SEED DATA & AI/EMAIL WIRING
=====================================================

Objective:
- Make the system DEMO-READY with realistic seed data, working AI stubs using OpenAI, and working email notifications using SendGrid.

A) Seed Data (idempotent & tenant-aware)

Implement a management command or protected endpoint, e.g.:
- `POST /api/admin/seed-demo`

Behavior:
- If demo tenant already exists → do nothing (idempotent).
- Otherwise:
  - Create demo tenant: "DemoCorp".
  - Create departments: "ERTMD", "TMSD", "JTMD".
  - Create users for that tenant:
    - 1 admin
    - 1 training officer
    - 2 managers
    - 3 foremen
    - ~10 employees
  - Assign realistic roles and departments.
  - Create 5–10 courses:
    - "Basic Safety Orientation"
    - "Electrical Safety L2"
    - "First Aid & CPR"
    - "SCADA Fundamentals"
    - "Cyber Security Awareness"
    - etc.
  - Create enrollments with mixed statuses:
    - Some completed, some active, some expiring soon, some expired.
  - Create progression_tasks per grade and employee_tasks with mixed completion.
  - Create some renewal_requests in states:
    - pending, approved, rejected.
  - Prepopulate KPI snapshots to make dashboards meaningful.

Document demo login credentials in README/replit.md (do NOT print passwords in logs).

B) AI Service Wiring (OpenAI)

Create an AI service module as per blueprint, e.g. `backend/app/services/ai_service.py`:

- Use:
  - `settings.OPENAI_API_KEY` OR `settings.AI_INTEGRATIONS_OPENAI_API_KEY`
  - `settings.AI_INTEGRATIONS_OPENAI_BASE_URL`
- Implement functions:
  - `generate_course_recommendations(user_id)`:
    - Uses user courses, tasks, expiring trainings.
    - If OpenAI key exists → call OpenAI with a lightweight prompt and return structured recommendations.
    - If no key → fall back to deterministic stub (e.g., recommend missing required courses).
  - `calculate_grade_readiness(user_id)`:
    - Use tasks completion %, training completion %, expired ratio.
    - If OpenAI key exists → allow it to refine the score.
    - If no key → simple rule-based score.

Expose endpoints:
- `POST /api/ai/recommendations`
- `POST /api/ai/grade-readiness`

These endpoints MUST delegate work to background jobs or async tasks. They should NOT block on long AI calls.

C) Email Notifications Wiring (SendGrid)

Create an EmailService, e.g. `backend/app/services/email_service.py`:

- Use:
  - `settings.SENDGRID_API_KEY`
  - `settings.EMAIL_FROM_ADDRESS`
  - `settings.EMAIL_FROM_NAME`
- Implement:
  - `send_email(to_address, subject, text_body, html_body=None)`
    - If SENDGRID_API_KEY is missing or EMAIL_FROM_ADDRESS unset:
      - Log a warning and do nothing (no crash).
    - Otherwise:
      - Use SendGrid SMTP or Web API to send emails.

Integrate EmailService into Notification Engine:

- When expiration job runs:
  - For each affected user:
    - Create in-app notification.
    - Send email about upcoming/expired training.
- When renewal_request is approved/rejected:
  - Notify employee via in-app notification and email.

Add a small test endpoint for internal use only (protected route), e.g.:
- `POST /api/admin/test-email`
  - Sends a test email to the current admin user.
  - Only callable by admin role.

D) Documentation

Update `replit.md` or README with:

- How to run backend and frontend.
- How to apply migrations.
- How to run or trigger demo seed.
- List of env vars and their purpose (without values).
- Demo login credentials (roles + usernames, not raw passwords, describe them generically if needed).

=====================================================
FINAL BEHAVIOR AFTER PHASE 4
=====================================================

When you finish implementing Phase 2, 3, and 4:

1) Ensure:
   - `poetry run` or `uvicorn` command to start backend is documented.
   - `npm/yarn pnpm` command to start frontend is documented.
   - Running the project plus calling the seed endpoint/command produces a working demo.

2) Then STOP and produce a clear summary including:
   - Implemented features per phase.
   - How to run backend & frontend.
   - How to trigger demo seed.
   - Default demo logins (role → username format).
   - Note on AI:
     - If OPENAI_API_KEY is present → real AI is used.
     - Otherwise, stub logic is used.

Do NOT start implementing Skill Graph Engine, Career Path AI, SCORM, or Security Awareness Simulator yet. Those will be future phases once this MVP is fully validated.

Begin implementation now, following these instructions strictly.
