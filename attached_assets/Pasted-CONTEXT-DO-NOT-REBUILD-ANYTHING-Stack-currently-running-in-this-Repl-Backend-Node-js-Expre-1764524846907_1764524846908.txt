CONTEXT (DO NOT REBUILD ANYTHING)


Stack currently running in this Repl:


Backend: Node.js + Express (under server/), with existing /api/v1/users/login endpoint and isAuthenticated middleware.


Frontend: React/TypeScript app in client/ folder (this is the active frontend).


There is already:


A working email/password login at /api/v1/users/login that:


Verifies user with bcrypt.


Sets a secure session / cookie.


Returns user info including role.




A useAuth hook in client/src/hooks/useAuth.ts that expects a GET /api/v1/users/me endpoint to validate the current session.


Role-based routing and sidebar logic using a helper (role ‚Üí default route) already implemented on the frontend.






Current bug:


Login succeeds (toast shows success, session cookie is set).


But the app redirects back to the landing page instead of the role-based dashboard because /api/v1/users/me does not exist on the backend, so useAuth fails and thinks the user is unauthenticated.




Your goal:
üîπ Add /api/v1/users/me on the Express backend and make sure the frontend useAuth hook uses it correctly so that role-based redirect works after login.
üîπ Do this without breaking any existing routes or changing schemas.

REQUIRED IMPLEMENTATION
1) Backend ‚Äì Add /api/v1/users/me Endpoint


Open the Express backend files (for example server/routes.ts or server/routes/users.ts ‚Äì use the actual structure in this Repl).


Locate:


The existing /api/v1/users/login route.


The authentication middleware (e.g. isAuthenticated, requireAuth, or similar).


The User model / DB access helper currently used in the login handler.




Implement this new endpoint:


Method: GET


Path: /api/v1/users/me


Middleware: must be protected with the same auth middleware used by other authenticated routes (e.g. isAuthenticated).


Behavior:


Read the authenticated user identity from the session / JWT / request object using the same pattern that the login endpoint uses (for example req.user, req.session.userId, or the decoded token).


Load the full user record from the database.


If no authenticated user is found, respond with 401 and { success: false, message: "Unauthorized" }.


If user is found, respond with 200 and a JSON payload that matches the shape used by the frontend and by the /login response.
Use the same property names already used in the login response. At minimum include:


id


email


role


firstName


lastName


plus any existing fields like departmentId, departmentName, grade, etc., if they already exist in the DB/model.




Do not add or rename columns in the database. Use the current schema as-is.






Do NOT:


Do not create new tables or run migrations.


Do not change the login response format.


Do not change how sessions/cookies/JWT are created ‚Äì just reuse the existing mechanism.




2) Frontend ‚Äì Ensure useAuth Uses /api/v1/users/me Correctly


Open client/src/hooks/useAuth.ts.


Verify that:


The hook calls GET /api/v1/users/me to fetch the current user.


It stores the returned user object (including role) in state or React Query cache.


It exposes:


user


isAuthenticated


login(credentials)


logout()




If useAuth is still calling some Replit-Auth endpoint or a different path, update it to use exactly /api/v1/users/me and expect the JSON shape returned by the backend.




After a successful login (HTTP 200 from /api/v1/users/login):


Make sure login():


Triggers a refetch or invalidation of the /api/v1/users/me query so that the latest user (with role) is available.


Waits for that fetch to succeed or, at minimum, ensures the auth state is updated before deciding routing.






Do NOT:


Do not alter the global app architecture.


Do not change existing type names or interfaces unless they clearly mismatch the backend response.




3) Frontend ‚Äì Role-Based Redirect After Login


Open client/src/pages/login.tsx.


Confirm there is already a helper for getting the default route based on role (e.g. getDefaultRouteForRole(role) in a roleRoutes.ts or similar util).


Update the login success logic to:


Call await login({ email, password }).


After login() completes and useAuth has the updated user, read user.role and compute the redirect path with the existing helper:


admin           ‚Üí /users


training_officer‚Üí /courses


manager         ‚Üí /kpi-dashboard


foreman         ‚Üí /approvals


employee        ‚Üí /dashboard




Use React Router‚Äôs navigation (navigate(defaultRoute, { replace: true })) to redirect.


If, for any reason, user is still null, fall back to /dashboard as a safe default.




Make sure there is no redirect back to the landing page after a successful login. Landing page / should only be for unauthenticated users (or when a user explicitly logs out).


4) Frontend ‚Äì App Router & Guards (Verification Only)


Open client/src/App.tsx and verify:


There is a ProtectedRoute (or similar) component already wrapping internal routes.


Internal dashboard routes (dashboard, courses, renewals, users, departments, etc.) remain protected and role-checked.


The landing page / remains public.


The login page /login remains public and is not accidentally wrapped in ProtectedRoute.




Do NOT:


Do not remove any existing routes.


Do not change the sidebar structure.


Do not touch landing page layout, animations, or Arabic/English content.





NON-FUNCTIONAL RULES


‚ùå No destructive DB operations: no DROP, no schema renames, no new migrations.


‚úÖ Reuse existing Express auth/session infrastructure.


‚úÖ Keep response formats backward-compatible.


‚úÖ Keep all current UI and animations intact.


‚úÖ Only add the /api/v1/users/me endpoint and adjust frontend auth wiring.



ACCEPTANCE CRITERIA


Using the browser:


Open https://training.rocktech.sa.


Click Login and sign in with any demo user, e.g.
admin@democorp.local / TrainFlow123!




Expected behavior:


Login request to /api/v1/users/login returns 200 and sets the session / auth cookie.


useAuth successfully fetches /api/v1/users/me and stores the user (with role).


User is redirected to the correct dashboard:


Admin ‚Üí /users


Training Officer ‚Üí /courses


Manager ‚Üí /kpi-dashboard


Foreman ‚Üí /approvals


Employee ‚Üí /dashboard




Refreshing the page keeps the user logged in and stays on the same protected route (no bounce back to landing).




Authorization:


Trying to manually access an admin route (e.g. /users) with a non-admin user shows the proper ‚ÄúAccess Denied/403‚Äù view.




Implement ONLY the changes required above, keeping the rest of the system exactly as it is.
